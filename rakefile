require 'erb'
require 'yaml'

require 'rake/clean'
require 'rake/testtask'

require 'fileutils'

require_relative 'zemu/config'

load '../z80-libraries/tasks.rake'

CLEAN.include("**/*.noi", "**/*.lk", "**/*.rst", "**/*.rel", "**/*.lst", "**/*.o", "**/*.bin", "**/*.hex", "**/*.diss", "**/*.lib", "**/*.lis", "**/*.map", "**/*.sym", "**/*.exe")

rule ".rel" => ".c" do |task|
    cmd = "sdcc -c -mz80 --opt-code-speed "
    cmd += "-o\"#{task.name}\" "
    cmd += "-I#{File.dirname(task.source)} "
    cmd += "-I#{LIB_INCLUDE} "
    cmd += "-DDEBUG "
    cmd += "#{task.source}"
    system(cmd)
    FileUtils.rm("#{File.dirname(task.source)}/#{File.basename(task.source, ".c")}.asm")
end

rule ".rel" => ".asm" do |task|
    cmd = "sdasz80 -plosgffw "
    cmd += "#{task.name} "
    cmd += task.source
    system(cmd)
end

def compile_sdcc(output_name, object_files, crt0, code_seg, data_seg)
    cmd = "sdcc -mz80 --opt-code-speed "
    cmd += "--no-std-crt0 "
    cmd += "-Wl-b_CODE=0x#{code_seg.to_s(16)} "
    cmd += "-Wl-b_DATA=0x#{data_seg.to_s(16)} "
    cmd += "-o #{File.basename(output_name, ".bin")}.hex "
    cmd += "-L#{LIB} "
    cmd += "#{crt0} "
    cmd += object_files.join(" ")
    cmd += " stdlib.lib"
    
    success = system("#{cmd} > link.log 2>&1")

    unless success
        abort("Link failed:\n#{File.read("link.log")}")
    end

    system("objcopy --gap-fill 0x76 -Iihex -Obinary #{File.basename(output_name, ".bin")}.hex #{output_name}")
    
    size = File.size(output_name)
    size_kb = size / 1024.0
    puts "#{output_name}: #{size_kb.round(1)}KB"

    true
end

# Helper function for running unit tests.
# Delete test exe and main.c if they exist.
def unit_test(directory)
    exe_name = "test_" + directory.gsub("/", "_") + ".exe"

    if File.exist? exe_name
        FileUtils.rm exe_name
    end

    if File.exist? "#{directory}/unit_test/main.c"
        FileUtils.rm "#{directory}/unit_test/main.c"
    end

    tests = []

    # Get tests from test files.
    Dir.glob("#{directory}/unit_test/*.c").each do |f|
        File.readlines(f).each do |l|
            if /int (test_\S+)\(\)/ =~ l
                tests << $1
            end
        end
    end

    # Create the templated main.
    template = File.read("#{directory}/unit_test/main.c.erb")
    erb = ERB.new(template)
    File.write("#{directory}/unit_test/main.c", erb.result(binding))

    # Compile test/main.c, other test/*.c, and kernel files for which
    # a file exists under test.
    # Include every source file but reset.asm, which is the startup code.
    src = []

    Dir.glob("#{directory}/unit_test/*.c").each do |f|
        next if f == "#{directory}/unit_test/main.c"

        src << f
    end

    Dir.glob("#{directory}/*.c").each do |f|
        next if f == "#{directory}/main.c"
        
        src << f
    end

    # Add mock files
    Dir.glob("#{directory}/unit_test/mock/*.c").each do |f|
        src << f
    end

    cmd = "gcc "
    cmd += "-g -O1 "
    cmd += "-DUNIT_TEST "
    cmd += "-I#{directory} "
    cmd += "-I#{directory}/unit_test/mock "
    cmd += "-o #{exe_name}.exe "
    cmd += src.join(" ")
    cmd += " #{directory}/unit_test/main.c"

    system(cmd)

    # Now run tests.
    if (!system("./#{exe_name}.exe"))
        puts "TESTS FAILED"
    else
        puts "TESTS PASSED"
    end
end

desc 'Start an instance of Z80-OS in the Zemu interactive debugger.'
task 'debug' => ['build:kernel_debug', 'build:command'] do
    unless File.exist?("disk_copy.bin")
        FileUtils.cp "zemu/disk.img", "disk_copy.bin"
    end

    zemu_start()
end

namespace 'build' do
    desc "Build boot sector image"
    task 'boot' do
        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "--no-crt "
        cmd += "-o bootsector_temp.bin "
        cmd += "boot/bootsector.asm"

        success = system(cmd)

        if success
            # Pad to 512 bytes.
            bin = File.read("bootsector_temp.bin", mode: "rb")
            abort("Boot sector too large: size is #{bin.size}") if bin.size > 512
            File.open("bootsector.bin", "wb") do |f|
                bin.bytes.each do |b|
                    f.putc b
                end

                (512-bin.size).times do
                    f.putc 0
                end
            end

            system("z88dk-dis -o 0x8000 bootsector.bin > bootsector.diss")
        end
    end

    desc "Build 2nd stage loader image"
    task 'loader' => ['lib:stdlib'] do
        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-DZ88DK "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "-Cl\"-r0x8200\" "
        cmd += "-crt0 loader/reset.asm "
        cmd += "-m "
        cmd += "-o loader_temp.bin "
        cmd += "loader/*.c "
        cmd += "loader/*.asm "

        success = system(cmd)

        if success
            num_sectors = 9

            bin = File.read("loader_temp.bin", mode: "rb")
            abort("Loader image too large: size is #{bin.size} (#{512 * num_sectors} expected)") if bin.size > (512*num_sectors)

            File.open("loader.bin", "wb") do |f|
                bin.bytes.each do |b|
                    f.putc b
                end

                ((512*num_sectors)-bin.size).times do
                    f.putc 0
                end
            end

            system("z88dk-dis -o 0x8200 loader.bin > loader.diss")

            File.open("loader.bin", "rb") do |f|
                num_sectors.times do |i|
                    File.open("loader_#{i+1}.bin", "wb") do |f_out|
                        512.times do
                            f_out.putc f.getc
                        end
                    end
                end
            end
        end
    end

    kernel_dependencies = FileList.new("kernel/*.c", "kernel/*.asm") do |fl|
        fl.exclude(/reset/)
    end.ext(".rel")

    desc "Build kernel image"
    task 'kernel' => ['lib:stdlib', 'kernel/reset.rel'] + kernel_dependencies do
        success = compile_sdcc("kernel.bin", kernel_dependencies, 'kernel/reset.rel', 0x0060, 0x6000)

        if success
            system("z88dk-dis -o 0x0000 kernel.bin > kernel.diss")

            # Make sure that the kernel image is no more than 32Kb in size.
            limit = 32 * 1024
            bin = File.read("kernel.bin", mode: "rb")
            abort("Kernel image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    desc "Build kernel image in debug mode for tests"
    task 'kernel_debug' => ['lib:stdlib', 'kernel/reset.rel'] + kernel_dependencies do
        success = compile_sdcc("kernel_debug.bin", kernel_dependencies, 'kernel/reset.rel', 0x0060, 0x6000)

        if success
            system("z88dk-dis -o 0x0000 kernel_debug.bin > kernel_debug.diss")

            # Make sure that the kernel image is no more than 32Kb in size.
            limit = 32 * 1024
            bin = File.read("kernel_debug.bin", mode: "rb")
            abort("Kernel image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    command_dependencies = FileList.new("command/*.asm", "command/*.c") do |fl|
        fl.exclude(/reset/)
    end.ext("rel")

    desc "Build command processor image"
    task 'command' => ['lib:stdlib', PROCESS_CRT0_OBJ] + command_dependencies do
        success = compile_sdcc("command.bin", command_dependencies, PROCESS_CRT0_OBJ, 0x8000, 0xd000)

        if success
            system("z88dk-dis -o 0x8000 command.bin > command.diss")

            # Make sure that the command processor image is no more than 32Kb in size.
            limit = 32 * 1024
            bin = File.read("command.bin", mode: "rb")
            abort("Command processor image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        # Open the YAML file for the builtin program.
        config = YAML.load_file(File.join(builtin, "config.yaml"))

        # Base address for the program.
        code_seg = config['code']
        data_seg = config['data']
        code_seg_hdr = code_seg >> 8

        builtin_dependencies = FileList.new("#{builtin}/*.asm", "#{builtin}/*.c").ext("rel")

        desc "Build executable for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}" => ['lib:stdlib', PROCESS_CRT0_OBJ] + builtin_dependencies do
            success = compile_sdcc("#{builtin_name}.bin", builtin_dependencies, PROCESS_CRT0_OBJ, code_seg, data_seg)

            if success
                system("z88dk-dis -o #{origin_string} #{builtin_name}.bin > #{builtin_name}.diss")

                # Now make an executable from the binary.
                File.open("#{builtin_name}.exe", "wb") do |f|
                    f.write([0x0a, code_seg_hdr].pack("CC"))
                    File.open("#{builtin_name}.bin", "rb") do |f2|
                        f2.each_byte do |b|
                            f.write([b].pack("C"))
                        end
                    end
                end
            end
        end
    end

    desc "Build all"
    task "all" => ["loader", "boot", "kernel", "command"] + Dir.glob("builtin/*").map { |builtin| "builtin:#{File.basename(builtin)}" }
end

namespace 'install' do
    desc "Install kernel image onto CF-card"
    task 'kernel', [:path] => ['build:kernel'] do |t, args|
        abort("No path specified") if args[:path].nil?
        FileUtils.cp('kernel.bin', File.join(args[:path], 'KERNEL.BIN'))
    end

    desc "Install command processor image onto CF-card"
    task 'command', [:path] => ['build:command'] do |t, args|
        abort("No path specified") if args[:path].nil?
        FileUtils.cp('command.bin', File.join(args[:path], 'COMMAND.BIN'))
    end

    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        desc "Install executable for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}", [:path] => ["build:builtin:#{builtin_name}"] do |t, args|
            abort("No path specified") if args[:path].nil?
            FileUtils.cp("#{builtin_name}.exe", File.join(args[:path], "#{builtin_name.upcase}.EXE"))
        end
    end
end

namespace 'test' do
    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        desc "Run unit tests for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}" do
            unit_test(builtin)
        end
    end

    namespace 'kernel' do
        desc "Run kernel integration tests"
        Rake::TestTask.new 'integration' => ["build:kernel_debug", "kernel/integration_test/reset.rel", "lib:process_crt0"] do |t|
            t.test_files = FileList['kernel/integration_test/test_*.rb']
        end

        desc "Run kernel unit tests"
        task 'unit' do
            unit_test("kernel")
        end

        desc "Run all kernel tests"
        task 'all' => ['test:kernel:unit', 'test:kernel:integration']
    end
end

namespace 'benchmark' do
    desc "Run kernel benchmarks"
    task 'kernel' => "build:kernel_debug" do
        Dir.glob("benchmark/kernel/*.rb").each do |b|
            require_relative "#{b}"
            if defined? benchmarks
                benchmarks()
                undef :benchmarks
            end
        end
    end
end

task "test" => ["test:kernel:all"]

task "install", [:path] => ["install:kernel", "install:command"] + Dir.glob("builtin/*").map { |builtin| "install:builtin:#{File.basename(builtin)}" }
