require 'erb'
require 'yaml'

require 'rake/clean'

require 'fileutils'

require_relative '../zemu/lib/zemu'

load '../z80-libraries/tasks.rake'

CLEAN.include("**/*.o", "**/*.bin", "**/*.hex", "**/*.diss", "**/*.lib", "**/*.lis", "**/*.map", "**/*.sym", "**/*.exe")

# Serial Input/Output object
#
# Represents a serial connection between the emulated CPU
# and the host machine, with input and output mapped to Z80 I/O
# ports.
class Serial6850 < Zemu::Config::IOPort
    # Constructor.
    #
    # Takes a block in which the parameters of the serial port
    # can be initialized.
    #
    # All parameters can be set within this block.
    # They become readonly as soon as the block completes.
    #
    # @example
    #   
    #   Zemu::Config::SerialPort.new do
    #       name "serial"
    #       in_port 0x00
    #       out_port 0x01
    #   end
    #
    #
    def initialize
        super

        when_setup do
            "#include <stdio.h>\n" +
            "zuint8 io_#{name}_tx;\n" +
            "zuint8 io_#{name}_rx;\n" +
            "zuint8 io_#{name}_status;\n" +
            "zuint8 io_#{name}_control;\n" +
            "zboolean int_#{name}_tx = FALSE;\n" +
            "zboolean int_#{name}_rx = FALSE;\n" +
            "\n" +
            "zusize zemu_io_#{name}_buffer_size(void)\n" +
            "{\n" +
            "    if (io_#{name}_status & 0x02) return 0;\n" +
            "    else return 1;\n" +
            "}\n" +
            "\n" +
            "void zemu_io_#{name}_master_puts(zuint8 val)\n" +
            "{\n" +
            "    io_#{name}_rx = val;\n" +
            "    io_#{name}_status |= 0x01;\n" +
            "    int_#{name}_rx = TRUE;\n" +
            "}\n" +
            "\n" +
            "zuint8 zemu_io_#{name}_master_gets(void)\n" +
            "{\n" +
            "    io_#{name}_status |= 0x02;\n" +
            "    return io_#{name}_tx;\n" +
            "}\n"
        end

        when_read do
            "if (port == #{data_port})\n" +
            "{\n" +
            "    io_#{name}_status &= ~0x01;\n" +
            "    int_#{name}_rx = FALSE;\n" +
            "    return io_#{name}_rx;\n" +
            "}\n" +
            "else if (port == #{control_port})\n" +
            "{\n" +
            "    return io_#{name}_status;\n" +
            "}\n"
        end

        when_write do
            "if (port == #{data_port})\n" +
            "{\n" +
            "    io_#{name}_status &= ~0x02;\n" +
            "    io_#{name}_tx = value;\n" +
            "}\n" +
            "else if (port == #{control_port})\n" +
            "{\n" +
            "    if ((value & 0x03) == 0x03) io_#{name}_status = 0x02;\n" +
            "    else io_#{name}_control = value;\n" +
            "}\n"
        end

        when_clock do
            "if ((io_#{name}_control & 0x20) && (io_#{name}_status & 0x02)) int_#{name}_tx = TRUE;\n" +
            "else int_#{name}_tx = FALSE;\n" +
            "if (int_#{name}_rx || int_#{name}_tx) { io_#{name}_status |= 0x80; zemu_io_int_on(instance); }\n" +
            "else { io_#{name}_status &= ~0x80; zemu_io_int_off(instance); }\n"
        end
    end

    # Defines FFI API which will be available to the instance wrapper if this IO device is used.
    def functions
        [
            {"name" => "zemu_io_#{name}_master_puts".to_sym, "args" => [:uint8], "return" => :void},
            {"name" => "zemu_io_#{name}_master_gets".to_sym, "args" => [], "return" => :uint8},
            {"name" => "zemu_io_#{name}_buffer_size".to_sym, "args" => [], "return" => :uint64}
        ]
    end

    # Valid parameters for a SerialPort, along with those
    # defined in [Zemu::Config::IOPort].
    def params
        super + %w(data_port control_port)
    end
end

desc "Emulate system using Zemu"
task 'run' => 'build:all' do
    conf = Zemu::Config.new do
        name "zemu_os"

        clock_speed 3_686_400
        serial_delay 0.0002

        add_memory (Zemu::Config::RAM.new do
            name "ram_lower"
            address 0x0000
            size    0x8000

            contents from_binary("../z80-bootloader/zboot.bin")
        end)

        add_memory (Zemu::Config::RAM.new do
            name "ram_upper"
            address 0x8000
            size    0x8000
        end)

        add_io (Serial6850.new do
            name "serial"
            control_port 0x00
            data_port 0x01
        end)

        add_io (Zemu::Config::BlockDrive.new do
            name "drive"
            base_port 0x18

            sector_size 512
            num_sectors 131072

            initialize_from "disk.bin"
        end)
    end

    puts "Starting emulator..."

    Zemu.start_interactive(conf)
end

namespace 'build' do
    desc "Build boot sector image"
    task 'boot' do
        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "--no-crt "
        cmd += "-o bootsector_temp.bin "
        cmd += "boot/bootsector.asm"

        success = system(cmd)

        if success
            # Pad to 512 bytes.
            bin = File.read("bootsector_temp.bin", mode: "rb")
            abort("Boot sector too large: size is #{bin.size}") if bin.size > 512
            File.open("bootsector.bin", "wb") do |f|
                bin.bytes.each do |b|
                    f.putc b
                end

                (512-bin.size).times do
                    f.putc 0
                end
            end

            system("z88dk-dis -o 0x8000 bootsector.bin > bootsector.diss")
        end
    end

    desc "Build 2nd stage loader image"
    task 'loader' => ['lib:stdlib'] do
        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "-Cl\"-r0x8200\" "
        cmd += "-crt0 loader/reset.asm "
        cmd += "-m "
        cmd += "-o loader_temp.bin "
        cmd += "loader/*.c "
        cmd += "loader/*.asm "

        success = system(cmd)

        if success
            num_sectors = 9

            bin = File.read("loader_temp.bin", mode: "rb")
            abort("Loader image too large: size is #{bin.size} (#{512 * num_sectors} expected)") if bin.size > (512*num_sectors)

            File.open("loader.bin", "wb") do |f|
                bin.bytes.each do |b|
                    f.putc b
                end

                ((512*num_sectors)-bin.size).times do
                    f.putc 0
                end
            end

            system("z88dk-dis -o 0x8200 loader.bin > loader.diss")

            File.open("loader.bin", "rb") do |f|
                num_sectors.times do |i|
                    File.open("loader_#{i+1}.bin", "wb") do |f_out|
                        512.times do
                            f_out.putc f.getc
                        end
                    end
                end
            end
        end
    end

    desc "Build kernel image"
    task 'kernel' => ['lib:stdlib'] do
        # Include every source file but reset.asm, which is the startup code.
        src = (Dir.glob("kernel/*.asm") + Dir.glob("kernel/*.c")) - ["kernel/reset.asm"]

        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-O2 -SO2 "
        cmd += "-DZ88DK "
        cmd += "-Ikernel "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "-Cl\"-r0x0000\" "
        cmd += "-crt0 kernel/reset.asm "
        cmd += "-lstdlib "
        cmd += "-m "
        cmd += "-o kernel.bin "
        cmd += src.join(" ")

        success = system(cmd)

        if success
            system("z88dk-dis -o 0x0000 kernel.bin > kernel.diss")

            # Make sure that the kernel image is no more than 23Kb in size.
            limit = 23 * 1024
            bin = File.read("kernel.bin", mode: "rb")
            abort("Kernel image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    desc "Build command processor image"
    task 'command' => ['lib:stdlib'] do
        # Include every source file but reset.asm, which is the startup code.
        src = (Dir.glob("command/*.asm") + Dir.glob("command/*.c")) - ["command/reset.asm"]

        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "-Cl\"-r0x6000\" "
        cmd += "-crt0 command/reset.asm "
        cmd += "-lstdlib "
        cmd += "-m "
        cmd += "-o command.bin "
        cmd += src.join(" ")

        success = system(cmd)

        if success
            system("z88dk-dis -o 0x6000 command.bin > command.diss")

            # Make sure that the command processor image is no more than 8Kb in size.
            limit = 8 * 1024
            bin = File.read("command.bin", mode: "rb")
            abort("Command processor image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        desc "Build executable for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}" => ['lib:stdlib'] do
            config = YAML.load_file(File.join(builtin, "config.yaml"))

            base_address = config["origin"]
            base_address_string = "0x%04X" % base_address

            src = (Dir.glob("#{builtin}/*.asm") + Dir.glob("#{builtin}/*.c"))

            cmd = "zcc "
            cmd += "+#{CONFIG} -compiler-sccz80 "
            cmd += "-O2 -SO2 "
            cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
            cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
            cmd += "-Cl\"-r#{base_address_string}\" "
            cmd += "-crt0 #{LIB}/crt0.asm "
            cmd += "-lstdlib "
            cmd += "-m "
            cmd += "-o #{builtin_name}.exe.tmp "
            cmd += src.join(" ")

            success = system(cmd)

            if success
                system("z88dk-dis -o #{base_address_string} #{builtin_name}.exe.tmp > #{builtin_name}.diss")

                # Place magic numbers at start of binary.
                File.open("#{builtin_name}.exe", "wb") do |f|
                    f.write [ 0xa5, base_address && 0x00ff, (base_address >> 8) && 0x00ff ].pack("CC")
                    File.open("#{builtin_name}.exe.tmp", "rb") do |f2|
                        f2.each_byte do |b|
                            f.write [ b ].pack("C")
                        end
                    end
                end
            end
        end
    end

    desc "Build all"
    task "all" => ["loader", "boot", "kernel", "command"]
end

namespace 'install' do
    desc "Install kernel image onto CF-card"
    task 'kernel', [:path] => ['build:kernel'] do |t, args|
        abort("No path specified") if args[:path].nil?
        FileUtils.cp('kernel.bin', File.join(args[:path], 'KERNEL.BIN'))
    end

    desc "Install command processor image onto CF-card"
    task 'command', [:path] => ['build:command'] do |t, args|
        abort("No path specified") if args[:path].nil?
        FileUtils.cp('command.bin', File.join(args[:path], 'COMMAND.BIN'))
    end

    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        desc "Install executable for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}", [:path] => ["build:builtin:#{builtin_name}"] do |t, args|
            abort("No path specified") if args[:path].nil?
            FileUtils.cp("#{builtin_name}.exe", File.join(args[:path], "#{builtin_name.upcase}.EXE"))
        end
    end
end

namespace 'test' do
    desc "Run kernel unit tests"
    task 'kernel' do
        # Delete test exe and main.c if they exist.
        if File.exist? "test_kernel.exe"
            FileUtils.rm "test_kernel.exe"
        end

        if File.exist? "kernel/test/main.c"
            FileUtils.rm "kernel/test/main.c"
        end
        
        tests = []

        # Get tests from test files.
        Dir.glob("kernel/test/*.c").each do |f|
            File.readlines(f).each do |l|
                if /int (test_\S+)\(\)/ =~ l
                    tests << $1
                end
            end
        end

        # Create the templated main.
        template = File.read("kernel/test/main.c.erb")
        erb = ERB.new(template)
        File.write("kernel/test/main.c", erb.result(binding))

        # Compile test/main.c, other test/*.c, and kernel files for which
        # a file exists under test.
        # Include every source file but reset.asm, which is the startup code.
        src = []

        Dir.glob("kernel/test/*.c").each do |f|
            next if f == "kernel/test/main.c"

            src << f
            src << "kernel/#{File.basename(f)}"
        end

        # Add mock files
        Dir.glob("kernel/test/mock/*.c").each do |f|
            src << f
        end

        cmd = "gcc "
        cmd += "-g -O1 "
        cmd += "-Ikernel "
        cmd += "-Ikernel/test/mock "
        cmd += "-o test_kernel.exe "
        cmd += src.join(" ")
        cmd += " kernel/test/main.c"

        system(cmd)

        # Now run tests.
        if (!system("./test_kernel.exe"))
            puts "TESTS FAILED"
        else
            puts "TESTS PASSED"
        end
    end
end

task "install", [:path] => ["install:kernel", "install:command"] +
    Dir.glob("builtin/*").map { |p| "install:builtin:#{File.basename(p)}" }
