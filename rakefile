require 'erb'
require 'yaml'

require 'rake/clean'
require 'rake/testtask'

require 'fileutils'

require_relative 'zemu/config'

load '../z80-libraries/tasks.rake'

CLEAN.include("**/*.o", "**/*.bin", "**/*.hex", "**/*.diss", "**/*.lib", "**/*.lis", "**/*.map", "**/*.sym", "**/*.exe")

# Helper function to compile something with ZCC.
def compile(output_name, source_files, include_dirs, defines, crt, origin)
    origin_string = "0x%04X" % origin

    cmd = "zcc "
    cmd += "+#{CONFIG} -compiler-sccz80 --opt-code-speed=all "

    cmd += "-O2 -SO2 "

    cmd += "-DZ88DK "

    defines.each do |d|
        cmd += "-D#{d} "
    end
    
    include_dirs.each do |i|
        cmd += "-I#{i} "
    end

    cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
    cmd += "-Ca\"-I#{LIB_INCLUDE}\" "

    cmd += "-Cl\"-r#{origin_string}\" "
    cmd += "-crt0 #{crt} "
    cmd += "-lstdlib "
    cmd += "-m "
    cmd += "-o #{output_name} "
    cmd += source_files.join(" ")

    success = system(cmd)

    size = File.size(output_name)
    size_kb = size / 1024.0
    puts "#{output_name}: #{size_kb.round(1)}KB"

    return success
end

# Helper function for running unit tests.
# Delete test exe and main.c if they exist.
def unit_test(directory)
    exe_name = "test_" + directory.gsub("/", "_") + ".exe"

    if File.exist? exe_name
        FileUtils.rm exe_name
    end

    if File.exist? "#{directory}/unit_test/main.c"
        FileUtils.rm "#{directory}/unit_test/main.c"
    end

    tests = []

    # Get tests from test files.
    Dir.glob("#{directory}/unit_test/*.c").each do |f|
        File.readlines(f).each do |l|
            if /int (test_\S+)\(\)/ =~ l
                tests << $1
            end
        end
    end

    # Create the templated main.
    template = File.read("#{directory}/unit_test/main.c.erb")
    erb = ERB.new(template)
    File.write("#{directory}/unit_test/main.c", erb.result(binding))

    # Compile test/main.c, other test/*.c, and kernel files for which
    # a file exists under test.
    # Include every source file but reset.asm, which is the startup code.
    src = []

    Dir.glob("#{directory}/unit_test/*.c").each do |f|
        next if f == "#{directory}/unit_test/main.c"

        src << f
    end

    Dir.glob("#{directory}/*.c").each do |f|
        next if f == "#{directory}/main.c"
        
        src << f
    end

    # Add mock files
    Dir.glob("#{directory}/unit_test/mock/*.c").each do |f|
        src << f
    end

    cmd = "gcc "
    cmd += "-g -O1 "
    cmd += "-DUNIT_TEST "
    cmd += "-I#{directory} "
    cmd += "-I#{directory}/unit_test/mock "
    cmd += "-o #{exe_name}.exe "
    cmd += src.join(" ")
    cmd += " #{directory}/unit_test/main.c"

    system(cmd)

    # Now run tests.
    if (!system("./#{exe_name}.exe"))
        puts "TESTS FAILED"
    else
        puts "TESTS PASSED"
    end
end

desc 'Start an instance of Z80-OS in the Zemu interactive debugger.'
task 'debug' => ['build:kernel_debug', 'build:command'] do
    unless File.exist?("disk_copy.bin")
        FileUtils.cp "zemu/disk.img", "disk_copy.bin"
    end

    zemu_start()
end

namespace 'build' do
    desc "Build boot sector image"
    task 'boot' do
        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "--no-crt "
        cmd += "-o bootsector_temp.bin "
        cmd += "boot/bootsector.asm"

        success = system(cmd)

        if success
            # Pad to 512 bytes.
            bin = File.read("bootsector_temp.bin", mode: "rb")
            abort("Boot sector too large: size is #{bin.size}") if bin.size > 512
            File.open("bootsector.bin", "wb") do |f|
                bin.bytes.each do |b|
                    f.putc b
                end

                (512-bin.size).times do
                    f.putc 0
                end
            end

            system("z88dk-dis -o 0x8000 bootsector.bin > bootsector.diss")
        end
    end

    desc "Build 2nd stage loader image"
    task 'loader' => ['lib:stdlib'] do
        cmd = "zcc "
        cmd += "+#{CONFIG} -compiler-sccz80 "
        cmd += "-DZ88DK "
        cmd += "-O2 -SO2 "
        cmd += "-L#{LIB} -I#{LIB_INCLUDE} "
        cmd += "-Ca\"-I#{LIB_INCLUDE}\" "
        cmd += "-Cl\"-r0x8200\" "
        cmd += "-crt0 loader/reset.asm "
        cmd += "-m "
        cmd += "-o loader_temp.bin "
        cmd += "loader/*.c "
        cmd += "loader/*.asm "

        success = system(cmd)

        if success
            num_sectors = 9

            bin = File.read("loader_temp.bin", mode: "rb")
            abort("Loader image too large: size is #{bin.size} (#{512 * num_sectors} expected)") if bin.size > (512*num_sectors)

            File.open("loader.bin", "wb") do |f|
                bin.bytes.each do |b|
                    f.putc b
                end

                ((512*num_sectors)-bin.size).times do
                    f.putc 0
                end
            end

            system("z88dk-dis -o 0x8200 loader.bin > loader.diss")

            File.open("loader.bin", "rb") do |f|
                num_sectors.times do |i|
                    File.open("loader_#{i+1}.bin", "wb") do |f_out|
                        512.times do
                            f_out.putc f.getc
                        end
                    end
                end
            end
        end
    end

    desc "Build kernel image"
    task 'kernel' => ['lib:stdlib'] do
        # Include every source file but reset.asm, which is the startup code.
        src = (Dir.glob("kernel/*.asm") + Dir.glob("kernel/*.c")) - ["kernel/reset.asm"]

        success = compile("kernel.bin", src, ["kernel"], [], "kernel/reset.asm", 0x0000)

        if success
            system("z88dk-dis -o 0x0000 kernel.bin > kernel.diss")

            # Make sure that the kernel image is no more than 23Kb in size.
            limit = 23 * 1024
            bin = File.read("kernel.bin", mode: "rb")
            abort("Kernel image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    desc "Build kernel image in debug mode for tests"
    task 'kernel_debug' => ['lib:stdlib'] do
        # Include every source file but reset.asm, which is the startup code.
        src = (Dir.glob("kernel/*.asm") + Dir.glob("kernel/*.c")) - ["kernel/reset.asm"]

        success = compile("kernel_debug.bin", src, ["kernel"], ["DEBUG"], "kernel/reset.asm", 0x0000)

        if success
            system("z88dk-dis -o 0x0000 kernel_debug.bin > kernel_debug.diss")

            # Make sure that the kernel image is no more than 23Kb in size.
            limit = 23 * 1024
            bin = File.read("kernel_debug.bin", mode: "rb")
            abort("Kernel image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    desc "Build command processor image"
    task 'command' => ['lib:stdlib'] do
        # Include every source file but reset.asm, which is the startup code.
        src = (Dir.glob("command/*.asm") + Dir.glob("command/*.c")) - ["command/reset.asm"]

        success = compile("command.bin", src, [], [], PROCESS_CRT0, 0x8000)

        if success
            system("z88dk-dis -o 0x8000 command.bin > command.diss")

            # Make sure that the command processor image is no more than 32Kb in size.
            limit = 32 * 1024
            bin = File.read("command.bin", mode: "rb")
            abort("Command processor image is too large: size is #{bin.size} (#{limit} expected)") if bin.size > limit
        end
    end

    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        # Open the YAML file for the builtin program.
        config = YAML.load_file(File.join(builtin, "config.yaml"))

        # Base address for the program.
        origin = config['origin']
        origin_string = "0x%04X" % origin
        origin_segment = origin >> 8

        desc "Build executable for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}" => ['lib:stdlib'] do
            src = (Dir.glob("#{builtin}/*.asm") + Dir.glob("#{builtin}/*.c"))

            success = compile("#{builtin_name}.bin", src, [], [], PROCESS_CRT0, origin)

            if success
                system("z88dk-dis -o #{origin_string} #{builtin_name}.bin > #{builtin_name}.diss")

                # Now make an executable from the binary.
                File.open("#{builtin_name}.exe", "wb") do |f|
                    f.write([0x0a, origin_segment].pack("CC"))
                    File.open("#{builtin_name}.bin", "rb") do |f2|
                        f2.each_byte do |b|
                            f.write([b].pack("C"))
                        end
                    end
                end
            end
        end
    end

    desc "Build all"
    task "all" => ["loader", "boot", "kernel", "command"] + Dir.glob("builtin/*").map { |builtin| "builtin:#{File.basename(builtin)}" }
end

namespace 'install' do
    desc "Install kernel image onto CF-card"
    task 'kernel', [:path] => ['build:kernel'] do |t, args|
        abort("No path specified") if args[:path].nil?
        FileUtils.cp('kernel.bin', File.join(args[:path], 'KERNEL.BIN'))
    end

    desc "Install command processor image onto CF-card"
    task 'command', [:path] => ['build:command'] do |t, args|
        abort("No path specified") if args[:path].nil?
        FileUtils.cp('command.bin', File.join(args[:path], 'COMMAND.BIN'))
    end

    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        desc "Install executable for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}", [:path] => ["build:builtin:#{builtin_name}"] do |t, args|
            abort("No path specified") if args[:path].nil?
            FileUtils.cp("#{builtin_name}.exe", File.join(args[:path], "#{builtin_name.upcase}.EXE"))
        end
    end
end

namespace 'test' do
    Dir.glob("builtin/*").each do |builtin|
        builtin_name = File.basename(builtin)

        desc "Run unit tests for builtin program '#{builtin_name}'"
        task "builtin:#{builtin_name}" do
            unit_test(builtin)
        end
    end

    namespace 'kernel' do
        desc "Run kernel integration tests"
        Rake::TestTask.new 'integration' => "build:kernel_debug" do |t|
            t.test_files = FileList['kernel/integration_test/test_*.rb']
        end

        desc "Run kernel unit tests"
        task 'unit' do
            unit_test("kernel")
        end
    end
end

namespace 'benchmark' do
    desc "Run kernel benchmarks"
    task 'kernel' => "build:kernel_debug" do
        Dir.glob("benchmark/kernel/*.rb").each do |b|
            require_relative "#{b}"
            if defined? benchmarks
                benchmarks()
                undef :benchmarks
            end
        end
    end
end

task "test" => ["test:kernel:unit", "test:kernel:integration"]

task "install", [:path] => ["install:kernel", "install:command"] + Dir.glob("builtin/*").map { |builtin| "install:builtin:#{File.basename(builtin)}" }
